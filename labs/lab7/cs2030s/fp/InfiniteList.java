package cs2030s.fp;

import java.util.ArrayList;
import java.util.List;
import java.util.NoSuchElementException;

/**
 * Represents an infinite list of elements of type T
 * that is lazily evaluated.
 *
 * @author Fikri (Lab 12A)
 * @version CS2030S AY22/23 Semester 2
 */
public class InfiniteList<T> {

  /**
   * Lazy evaluated head of the infinite list.
   */
  private final Lazy<Maybe<T>> head;

  /**
   * Lazy evaluated tail of the infinite list.
   */
  private final Lazy<InfiniteList<T>> tail;

  /**
   * A sentinel instance to represent the end of the list.
   */
  private static final Sentinel SENTINEL = new Sentinel(); 

  /**
   * Private constructor that initializes head and
   * tail as null.
   */
  private InfiniteList() { 
    this.head = null; 
    this.tail = null;
  }

  /**
   * Generates an infinite list from the given producer.
   *
   * @param <T> Type of the elements in the infinite list.
   * @param producer The producer that produces each element in the
   *     infinite list.
   * @return A new infinite list generated by applying the 
   *     given producer.
   */
  public static <T> InfiniteList<T> generate(Producer<T> producer) {
    return new InfiniteList<>(
        Lazy.of(() -> Maybe.some(producer.produce())),
        Lazy.of(() -> InfiniteList.generate(producer)));
  }

  /**
   * Create a new infinite list by iteratively applying the given next
   * function to the given seed value.
   *
   * @param <T> Type of the elements in the infinite list.
   * @param seed Initial value in the iteration.
   * @param next Transfomer function that iteratively generates new elements
   *     from the previous element.
   * @return A new infinite list iteratively generated from seed.
   */
  public static <T> InfiniteList<T> iterate(T seed, Transformer<T, T> next) {
    return new InfiniteList<>(
        seed,
        () -> InfiniteList.iterate(next.transform(seed), next));
  }

  /**
   * Constructs a new infinite list from given head element
   * and tail of the list produced by given producer function.
   *
   * @param head Head element of the list.
   * @param tail Producer function that will produce the tail of
   *     the list.
   */
  private InfiniteList(T head, Producer<InfiniteList<T>> tail) {
    this.head = Lazy.of(Maybe.some(head));
    this.tail = Lazy.of(tail);
  }

  /**
   * Constructs a new infinite list with the given lazy head and
   * lazy tail.
   *
   * @param head Lazy evaluated head of the list.
   * @param tail Lazy evaluated tail of the list.
   */
  private InfiniteList(Lazy<Maybe<T>> head, Lazy<InfiniteList<T>> tail) {
    this.head = head;
    this.tail = tail;
  }

  /**
   * Returns the first present head in the list.
   *
   * @return First present head in the list.
   */
  public T head() {
    return this.head.get().orElseGet(() -> this.tail.get().head());
  }

  /**
   * Returns the tail of the first present head in the list.
   *
   * @return Tail of first present head in the list.
   */
  public InfiniteList<T> tail() {
    return this.head.get().map(x -> this.tail.get()).orElseGet(() -> this.tail.get().tail());
    //return this.getListWithPresentHead().tail.get();
  }

  /**
   * Returns the list with the first present head.
   *
   * @return List with first present head.
   */
  protected InfiniteList<T> getListWithPresentHead() {
    return this.head.get()
      .map(x -> this)
      .orElseGet(() -> this.tail.get()
          .getListWithPresentHead());
  }

  /**
   * Returns a new InfiniteList by applying mapper to each element
   * in the current list lazily.
   *
   * @param <R> Type of the elements in the new list.
   * @param mapper Transformer function to apply to each element.
   * @return The new InfiniteList with each element transformed by mapper.
   */
  public <R> InfiniteList<R> map(Transformer<? super T, ? extends R> mapper) {
    return new InfiniteList<>(
        this.head.map(x -> x.map(mapper)),
        this.tail.map(x -> x.map(mapper)));
  }

  /**
   * Returns a new InfiniteList containing only elements of current
   * list that satisfies the predicate.
   *
   * @param predicate BooleanCondition to satisfy.
   * @return The new InfiniteList with elements that satisfies the
   *     predicate.
   */
  public InfiniteList<T> filter(BooleanCondition<? super T> predicate) {
    return new InfiniteList<>(
        this.head.map(x -> x.filter(predicate)),
        this.tail.map(x -> x.filter(predicate)));
  }

  /**
   * Returns a setinel.
   *
   * @param <T> Type of the sentinel list.
   * @return A sentinel.
   */
  public static <T> InfiniteList<T> sentinel() {
    // It is safe to tpye cast here as
    // Sentinel is a class with nothingness that cannot be modified
    // T <: Object
    @SuppressWarnings("unchecked")
    InfiniteList<T> s = (InfiniteList<T>) InfiniteList.SENTINEL;
    return s;
  }

  /**
   * Returns a new InfiniteList that terminates after the first
   * n elements in the current list.
   * Returns the entire list if the current list has less than n elements.
   * Elements refer to only elements that are still present (not Maybe.none()).
   *
   * @param n Maximum number of elements to include.
   * @return The new InfiniteList that terminates after the first n
   *     elements.
   */
  public InfiniteList<T> limit(long n) {
    return n <= 0
      ? InfiniteList.sentinel()
      : new InfiniteList<>(
          this.head,
          this.tail.map(
            tailList -> tailList.limit(this.head.get().map(x -> n - 1).orElseGet(() -> n))));
  }

  /**
   * Returns a new InfiniteList that truncates the current list as soon
   * as it finds an element that fails the predicate.
   * Elements refer to only eleemnts that are still present (not Maybe.none()).
   *
   * @param predicate BooleanCondition used to test each element.
   * @return The new InfiniteList truncated at the first element that fails the
   *     predicate.
   */
  public InfiniteList<T> takeWhile(BooleanCondition<? super T> predicate) {
    Lazy<Maybe<T>> h = Lazy.of(() -> Maybe.some(this.head()).filter(predicate));
    return new InfiniteList<>(
        h,
        h.map(maybeH -> maybeH
          .map(x -> this.tail().takeWhile(predicate))
          .orElseGet(() -> InfiniteList.sentinel())));
  }

  /**
   * Returns whether the current list is a sentinel.
   *
   * @return Whether the current list is a sentinel.
   */
  public boolean isSentinel() {
    return false;
  }

  /**
   * Reduces the current list from left to right using the given accumalator
   * and given identity.
   * Ignores any elements that are not present (Maybe.none()).
   *
   * @param <U> Type of reduced value.
   * @param identity Initial value used in the reduction.
   * @param accumulator Combiner function used to reduce each element.
   * @return The resulting reduced value.
   */
  public <U> U reduce(U identity, Combiner<U, ? super T, U> accumulator) {
    return this.head.get()
      .map(x -> this.tail.get().reduce(accumulator.combine(identity, x), accumulator))
      .orElseGet(() -> this.tail.get().reduce(identity, accumulator));
  }

  /**
   * Counts the number of present elements in the current list.
   *
   * @return The number of present elements.
   */
  public long count() {
    return this.reduce(0L, (res, x) -> res + 1);
  }

  /**
   * Collects the elements in the current list into a java.uti.List.
   *
   * @return The java.util.List of all elements in the current
   *     infinite list.
   */
  public List<T> toList() {
    List<T> lst = new ArrayList<T>();
    this.head.get().ifPresent(t -> lst.add(t));
    lst.addAll(this.tail.get().toList());
    return lst;
  }

  /**
   * Returns the string representation of the current list.
   *
   * @return THe string representation of the current list.
   */
  @Override
  public String toString() {
    return "[" + this.head + " " + this.tail + "]";
  }

  /**
   * Private inner class that represents at the end of an InfiniteList
   * to denote it as a finite list.
   * This class does not contain any data but overrides certain methods
   * of its superclass to simplify implementation.
   */
  private static class Sentinel extends InfiniteList<Object> {
    /**
     * Returns the string representation of the sentinel element.
     *
     * @return The string representation of the sentinel element.
     */
    @Override
    public String toString() {
      return "-";
    }

    /**
     * Throws a NoSuchElementException because sentinel element has no head.
     *
     * @throws NoSuchElementException thrown because sentinel has no head.
     */
    @Override
    public Object head() {
      throw new NoSuchElementException();
    }

    /**
     * Throws a NoSuchElementException because sentinel has no tail.
     *
     * @throws NoSuchElementException thrown because sentinel has no tail.
     */
    @Override
    public InfiniteList<Object> tail() {
      throw new NoSuchElementException();
    }

    /**
     * Returns an instance of the sentinel element.
     *
     * @return An instance of the sentinel element.
     */
    @Override
    protected InfiniteList<Object> getListWithPresentHead() {
      return InfiniteList.sentinel();
    }

    /**
     * Returns an instance of the sentinel element since sentinel has no value.
     *
     * @param <R> The type of the resulting elements in the new InfiniteList.
     * @param mapper The transformer function to apply to sentinel element.
     * @return An instance of the sentinel element.
     */
    @Override
    public <R> InfiniteList<R> map(Transformer<? super Object, ? extends R> mapper) {
      return InfiniteList.sentinel();
    }

    /**
     * Returns an instance of the sentinel element since sentinel element has no
     * value to apply to the given predicate.
     *
     * @param predicate The predicate to filter each element.
     * @return An instance of the sentinel element.
     */
    @Override
    public InfiniteList<Object> filter(BooleanCondition<? super Object> predicate) {
      return InfiniteList.sentinel();
    }

    /**
     * Returns an instance of the sentinel element since sentinel has no element to limit.
     *
     * @param n The maximum number of elemnts to return.
     * @return An instance of the sentinel element.
     */
    @Override
    public InfiniteList<Object> limit(long n) {
      return InfiniteList.sentinel();
    }

    /**
     * Returns a new instance of the sentinel element since the sentinel element has no
     * value to fulfil the given predicate.
     *
     * @param predicate The BooleanCondition to apply to each element.
     * @return An instance of the sentinel element.
     */
    @Override
    public InfiniteList<Object> takeWhile(BooleanCondition<? super Object> predicate) {
      return InfiniteList.sentinel();
    }

    /**
     * Returns true since the sentinel element is always a sentinel.
     *
     * @return true.
     */
    @Override
    public boolean isSentinel() {
      return true;
    }

    /**
     * Returns the identity since the sentinel element has no elements to reduce.
     *
     * @param <U> The type of the identity and the result of the Combiner.
     * @param identity The identity value for the Combiner.
     * @param accumulator The function to combine two elements into one.
     * @return The identity value.
     */
    @Override
    public <U> U reduce(U identity, Combiner<U, ? super Object, U> accumulator) {
      return identity;
    }

    /**
     * Returns 0 because the length of a sentinel element is 0.
     *
     * @return 0.
     */
    @Override
    public long count() {
      return 0;
    }

    /**
     * Returns an empty list because sentinel is represented by an empty list.
     *
     * @return An empty list.
     */
    @Override
    public List<Object> toList() {
      return List.of();
    }
  }
}
